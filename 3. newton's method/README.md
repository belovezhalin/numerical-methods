# Task Description

Your task is to create a set of functions that compute fixed points and zeros of multivariable functions. While you have complete freedom in choosing the method, the recommended approach is Newton's method. The names and arguments of the required functions are described below.

## Submission Guidelines
Submit a file named `source.cpp` to the BaCa system. This file should contain definitions of all required functions but should **not** include a `main` function. The testing programs for your solution will follow this structure:

```cpp
#include "source.cpp"
// Auxiliary test functions

int main() {
    // Main test implementation
}
```

## Output Formatting
Results should be printed with an accuracy of 17 significant digits. You may use the following function:

```cpp
void printVector(const double* x, unsigned N) {
    for (unsigned i = 0; i < N; ++i)
        printf("%17.17f ", x[i]);
    printf("\n");
}
```

## Computational Accuracy
The results generated by your programs should match the reference solution. The allowed tolerances are as follows:
- **Absolute tolerance:** \(10^{-13}\)
- **Relative tolerance:** \(10^{-6}\)

A result with an error smaller than the maximum permissible deviation will also be accepted. Higher accuracy is encouraged.

## Function Arguments
In this task, the arguments for all required functions will be pointers to functions that your algorithm should process. The function pointers will have the following signature:

```cpp
void (*f)(const double* x, double* y, double* Df);
```
which can be defined as:

```cpp
typedef void (*FuncPointer)(const double* x, double* y, double* Df);
```

This function represents a mapping \( f: \mathbb{R}^N \to \mathbb{R}^M \), where:
- `x` is an array of length \(N\), representing the input vector.
- `y` is an array of length \(M\), where the function stores the computed \( f(x) \). The function assumes that `y` has at least \(M\) elements.
- `Df` is an array of length \(M \times N\), where the function stores the computed Jacobian matrix \( Df(x) \). The function assumes that `Df` has at least \(N \times M\) elements.

### Matrix Representation
Matrices will be represented as one-dimensional arrays, with rows stored sequentially. For example, the matrix:

```
| 1  2  3  4 |
| 5  6  7  8 |
```

will be stored as:
```
1 2 3 4 5 6 7 8
```

# List of Required Functions

## `findCurve`
### Signature:
```cpp
int findCurve(FuncPointer f, double* x, unsigned k, double h);
```
This function computes and prints selected points \( x_1, x_2, ..., x_k \) that satisfy \( f(x_i) = (f_1(x_i), f_2(x_i)) = (0,0) \) with accuracy \( \max(|f_1(x_i)|, |f_2(x_i)|) \leq 10^{-14} \).

### Arguments:
- `f`: Function pointer for \( f: \mathbb{R}^3 \to \mathbb{R}^2 \).
- `x`: An array of three `double` values representing the starting point near the functionâ€™s root.
- `k`: Number of points to determine.
- `h`: Step size for parameter changes.

If the function fails to find a root for any \( i = 1, ..., k \), it should terminate without printing incorrect values and return the index \( i \) where the problem occurred. Otherwise, it should return 0.

## `findSurface`
### Signature:
```cpp
int findSurface(FuncPointer f, double* x, unsigned k1, unsigned k2, double h1, double h2);
```

### Description:
Finds and prints points satisfying \( f(x) = 0 \) with \( |f(x_i)| \leq 10^{-14} \).

### Arguments:
- `f`: Function pointer for \( f: \mathbb{R}^3 \to \mathbb{R} \).
- `x`: Array of three `double` values representing the starting point near the function's root.
- `k1`, `k2`: Number of points to determine.
- `h1`, `h2`: Step sizes for parameters.

If a root cannot be determined for any \( i = 1, ..., k1 \) or \( j = 1, ..., k2 \), the function should terminate and return \( i \times k1 + j \). Otherwise, return 0.

## `findFixedPoints`
### Signature:
```cpp
int findFixedPoints(FuncPointer f, double* x, unsigned k1, unsigned k2, double h1, double h2);
```

### Description:
Finds and prints vectors \( (x, y, a, b) \) satisfying \( f(x, y, a, b) = f_{a,b}(x, y) = (x, y) \) with \( |f_{a,b}(x, y) - (x, y)| \leq 10^{-14} \) in maximum norm.

### Arguments:
- `f`: Function pointer for \( f: \mathbb{R}^4 \to \mathbb{R}^2 \).
- `x`: Array of four `double` values, representing a starting point satisfying \( f(x_0, y_0, a_0, b_0) \approx (x_0, y_0) \).
- `k1`, `k2`: Number of points to determine.
- `h1`, `h2`: Step sizes for parameters.

If a fixed point cannot be determined for any \( i = 1, ..., k1 \) or \( j = 1, ..., k2 \), the function should terminate and return \( i \times k1 + j \). Otherwise, return 0.

---

# Example Tests

## `findCurve` Example
```cpp
#include "source.cpp"

void implicitCurve(const double* x, double* y, double* Df) {
    const double n = x[0]*x[0] + x[1]*x[1] + x[2]*x[2];
    const double r = 1.0 / n;
    const double s = (x[0] + x[1] + x[2]) * r;
    
    y[0] = 1.0 - n;
    y[1] = s - 1.0;
    
    Df[0] = -2.0 * x[0];
    Df[1] = -2.0 * x[1];
    Df[2] = -2.0 * x[2];
    
    const double r2 = 2.0 * s * r;
    Df[3] = r - x[0] * r2;
    Df[4] = r - x[1] * r2;
    Df[5] = r - x[2] * r2;
}

int main() {
    double x[3] = {0.25*(1.0+sqrt(5.0)), 0.25*(1.0-sqrt(5.0)), 0.5};
    findCurve(implicitCurve, x, 10, 1.0 / 128);
    return 0;
}
```
### Output:
```
0.12039238685063169 -0.27776699437494745 0.53125000000000000 
0.12427103856508417 -0.27776699437494745 0.56250000000000000 
0.13082600313543147 -0.27776699437494745 0.59375000000000000 
0.14020352633612365 -0.27776699437494745 0.62500000000000000 

0.06212351672030310 -0.24651699437494745 0.53125000000000000 
0.06548172983245609 -0.24651699437494745 0.56250000000000000 
0.07113718439412973 -0.24651699437494745 0.59375000000000000 
0.07918248954042481 -0.24651699437494745 0.62500000000000000 

0.01274589354441671 -0.21526699437494745 0.53125000000000000 
0.01576154969082753 -0.21526699437494745 0.56250000000000000 
0.02082981701922552 -0.21526699437494745 0.59375000000000000 
0.02801681517470467 -0.21526699437494745 0.62500000000000000 

-0.03023031684944523 -0.18401699437494745 0.53125000000000000 
-0.02746042638880794 -0.18401699437494745 0.56250000000000000 
-0.02281133203696253 -0.18401699437494745 0.59375000000000000 
-0.01623226497988585 -0.18401699437494745 0.62500000000000000
```
## `findSurface` Example
```cpp
#include "source.cpp"

  void implicitSurface(const double* x, double* y, double* Df){
    // funkcja dana jest wzorem f(a,b,c) = (a+b+c)/(a^2+b^2+c^2)-1
    // zmienne pomocnicze
    const double n = x[0]*x[0] + x[1]*x[1] + x[2]*x[2];
    const double s = x[0] + x[1] + x[2];
    
    // obliczam wartosc funkcji
    *y = s/n - 1.;
    
    //obliczam pierwszy i jedyny wiersz macierzy
    const double r = 1./n;
    const double r2 = 2.*(*y)*r;
    Df[0] = r - x[0]*r2;
    Df[1] = r - x[1]*r2;
    Df[2] = r - x[2]*r2;
  }

  int main(){
    double x[3] = {0.25*(1.+sqrt(5.)),0.25*(1.-sqrt(5.)),0.5};
    findSurface(implicitSurface,x,4,4,1./32,1./32);
    return 0;
  }
```
### Output:
```
0.12039238685063169 -0.27776699437494745 0.53125000000000000 
0.12427103856508417 -0.27776699437494745 0.56250000000000000 
0.13082600313543147 -0.27776699437494745 0.59375000000000000 
0.14020352633612365 -0.27776699437494745 0.62500000000000000 

0.06212351672030310 -0.24651699437494745 0.53125000000000000 
0.06548172983245609 -0.24651699437494745 0.56250000000000000 
0.07113718439412973 -0.24651699437494745 0.59375000000000000 
0.07918248954042481 -0.24651699437494745 0.62500000000000000 

0.01274589354441671 -0.21526699437494745 0.53125000000000000 
0.01576154969082753 -0.21526699437494745 0.56250000000000000 
0.02082981701922552 -0.21526699437494745 0.59375000000000000 
0.02801681517470467 -0.21526699437494745 0.62500000000000000 

-0.03023031684944523 -0.18401699437494745 0.53125000000000000 
-0.02746042638880794 -0.18401699437494745 0.56250000000000000 
-0.02281133203696253 -0.18401699437494745 0.59375000000000000 
-0.01623226497988585 -0.18401699437494745 0.62500000000000000
```

## `findFixedPoints` Example
```cpp
#include "source.cpp"

  void henon(const double* x, double* y, double* Df){
    // funkcja dana jest wzorem henon(x,y,a,b) = (1+y-a*x^2,b*x)
    const double x2 = x[0]*x[0];
    
    y[0] = 1 + x[1] - x[2]*x2;
    y[1] = x[3]*x[0];
    
    //obliczam pierwszy wiersz macierzy
    Df[0] = -2*x[2]*x[0];
    Df[1] = 1.;
    Df[2] = -x2;
    Df[3] = 0.;
    
    //obliczam drugi wiersz macierzy
    Df[4] = x[3];
    Df[5] = 0.;
    Df[6] = 0.;
    Df[7] = x[0];
  }

  int main(){
    double x[4] = {-1.2807764064044151, -0.6403882032022076, 1.0000000000000000, 0.50000000000000000};
    findFixedPoints(henon,x,4,4,1./16,1./16);
    return 0;
  }
```
### Output:
```
-1.19763031176984502 -0.67366705037053787 1.06250000000000000 0.56250000000000000 
-1.16253262436707128 -0.72658289022941946 1.06250000000000000 0.62500000000000000 
-1.12828395985954577 -0.77569522240343769 1.06250000000000000 0.68750000000000000 
-1.09489692504918534 -0.82117269378688895 1.06250000000000000 0.75000000000000000 

-1.15709574728685860 -0.65086635784885805 1.12500000000000000 0.56250000000000000 
-1.12409377442300484 -0.70255860901437794 1.12500000000000000 0.62500000000000000 
-1.09187315546713570 -0.75066279438365580 1.12500000000000000 0.68750000000000000 
-1.06044486059083676 -0.79533364544312757 1.12500000000000000 0.75000000000000000 

-1.12017996019888111 -0.63010122761187060 1.18750000000000000 0.56250000000000000 
-1.08904242173442811 -0.68065151358401754 1.18750000000000000 0.62500000000000000 
-1.05862710283202821 -0.72780613319701948 1.18750000000000000 0.68750000000000000 
-1.02894361972548642 -0.77170771479411493 1.18750000000000000 0.75000000000000000 

-1.08638630667790914 -0.61109229750632399 1.25000000000000000 0.56250000000000000 
-1.05691785736085264 -0.66057366085053293 1.25000000000000000 0.62500000000000000 
-1.02811959340942205 -0.70683222046897776 1.25000000000000000 0.68750000000000000 
-1.00000000000000000 -0.75000000000000000 1.25000000000000000 0.75000000000000000
```
